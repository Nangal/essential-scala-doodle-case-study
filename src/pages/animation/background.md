## Background

Our goal is to produce smooth animations and allow our animations to react to key presses and other events.
Let's start by looking at the first part of our goal: producing smooth animations.

To make smooth animations we must account for the characteristics of the screen. 
Screens typically redraw sixty times a second, so we should create new frames at the same rate. 
We also need to produce our frames at the point in time when the screen is ready to redraw, or we might observe [screen tearing](https://en.wikipedia.org/wiki/Screen_tearing).

The typical imperative solution is to setup a callback that is called every time a new frame is needed. The `Canvas` interface provides this facility, with a method `setAnimationFrameCallback`. 

```scala
def setAnimationFrameCallback(callback: Double => Unit): Unit
```

We pass a function to `setAnimationFrameCallback`, and the `Canvas` calls this function every time the screen is ready for a new frame. We then call other methods on `Canvas` to actually create that frame.

This interface has the all problems of the imperative approach to drawing that we abandoned in the last chapter: it doesn't compose, is difficult to work with, and is difficult to reason about. What would a better, functional, approach be?

When we look at a what an animation is, we find it quite amenable to a functional approach. Imagine we are animating a ball moving about the screen. The current position of the ball is a function of the previous postion and the current velocity.

![Current position is equal to the previous position plus the current velocity.](src/pages/animation/current-position.png)

The current velocity is itself a function of the user input and the previous velocity.

Let's see how this looks in code.

We start with a type to represent user input.

```tut:silent:book
// User input is a Key
sealed trait Key
final case object Up extends Key
final case object Down extends Key
final case object Left extends Key
final case object Right extends Key
```

Now we can calculate velocity as a function of the velocity at the previous timestep and user input.

```scala
// Velocity is represented as a two dimensional vector of type `Vec`
def currentVelocity(previousVelocity: Vec, input: Key): Vec =
  input match {
    case Up => previousVelocity + Vec(0, 1)
    case Down => previousVelocity + Vec(0, -1)
    case Left => previousVelocity + Vec(-1, 0)
    case Right => previousVelocity + Vec(1, 0)
  }
```

Location is a function of the location at the previous time step and the velocity.

```scala
// Location is represented as a two dimensional vector, by abuse of notation
def currentLocation(previousLocation: Vec, velocity: Vec): Vec =
  previousLocation + velocity
```

Given the current location we can draw a ball at that location. (You might not have implemented the `at` method in your version of Doodle. It places an `Image` at the given coordinates in the local coordinate system of the enclosing `Image`, or in the global coordinate system if there is no enclosing `Image`.)

```scala
// A simple image of a ball
val ball = Circle(10) fillColor Color.red

def currentBall(currentLocation: Vec): Image =
  ball at currentLocation
```

This is a good example of functional code: we've broken the problem down into small independent functions that we then compose to build the complete solution. We're still missing some parts though: how is user input obtained for example?

If we ignore interactivity for now, we can actually run the code above using `Lists` to provide the input. We `scanLeft` `currentVelocity` and `currentLocation`, and `map` `currentBall`.

You might not have seen the `scan` methods before. They are equivalent to fold but they collect the intermediate results in a list. Taking summing the elements of a `List` using a fold like so:

```tut:book
List(1, 2, 3, 4).foldLeft(0){ _ + _ }
```

If we replace `foldLeft` with `scanLeft` we get a list of the partial sums.

```tut:book
List(1, 2, 3, 4).scanLeft(0){ _ + _ }
```

We can apply this to our `Image` example to get a list of intermediate image frames.

```scala
val input = List(Up, Up, Down, Down, Left, Right, Left, Right)

val images: List[Image] =
  input.scanLeft(Vec(0, 0)){ currentVelocity }.
    scanLeft(Vec(0, 0)){ currentLocation }.
    map(currentBall)
```

Our resulting list of images is something that we could display to make an animation.

This system is fine for rendering animations from prerecorded input, but how what about responding in real-time to user input? The values of a `List` are all known in advance, while user input only becomes available when keys are pressed. What we want is some kind of sequence of data where the elements are generated by external input. Imagine, for example, something like a list of keypresses where the next element springs into existence when the user presses a key. We've seen above that the basic interface of `map` and `scanLeft` allows us to express at least some animations.

We can think of a list as representing data in space. Different list indices correspond to different locations in the computer's memory. What we want is an abstraction that represents data *in time*. Indexing in this event stream corresponds to accessing events at different times. (We won't actually implement indexing as it would allow time travel, but it provides a useful conceptual model.)

The next leap is to realise that it's the interface allowing transformation (`map`, `scanLeft`, and so on) that is important, not the list-like nature. We don't want to actually store all the past inputs in memory like we would in a list. 
We can make an analogy to an assembly line.
The raw materials flowing onto the assembly line are the user input.
Our transformations are stages of the assemblly line, turning input into output.
Our assembly line can branch or merge as needed.
The final destination of our assembly line is the screen and our final output should be `Images`.
