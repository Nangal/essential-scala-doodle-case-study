## Background

The typical imperative approach is animation is to setup a callback that is called every time a new frame should be rendered. The `Canvas` interface provides this facility, with a method `setAnimationFrameCallback`.

This has the all problems of imperative approach to drawing that we abandoned in the last chapter: it doesn't compose, is difficult to work with, and is difficult to reason about. What would be a better, functional, approach be?

When we look at a what an animation is, we find it quite amenable to a functional approach. Imagine we are animating a ball moving about the screen. The current position of the ball is a function of the previous postion and the current velocity. The current velocity is itself a function of the user input and the previous velocity. Let's quickly sketch out some code to make this really concrete.


We start with a type to represent user input.

```scala
// User input is a KeyPress
sealed trait KeyPress
final case class Up extends KeyPress
final case class Down extends KeyPress
final case class Left extends KeyPress
final case class Right extends KeyPress
```

Now we can calculate velocity as a function of the velocity at the previous timestep and user input.

```scala
// Velocity is represented as a two dimensional Vector
def currentVelocity(input: KeyPress, previousVelocity: Vec): Vec =
  input match {
    case Up => previousVelocity + Vec(0, 1)
    case Down => previousVelocity + Vec(0, -1)
    case Left => previousVelocity + Vec(-1, 0)
    case Right => previousVelocity + Vec(1, 0)
  }
```

Location is a function of the location at the previous time step and the velocity.

```scala
// Location is represented as a two dimensional Vector, by abuse of notation
def currentLocation(velocity: Vec, previousLocation: Vec): Vec =
  previousLocation + velocity
```

Given the current location we can draw at that location. (You might not have implemented the `at` method in your version of Doodle. It places an `Image` at the given coordinates in the local coordinate system of the enclosing `Image`, or in the global coordinate system if there is no enclosing `Image`.)

```scala
// A simple image of a ball
val ball = Circle(10) fillColor Color.red

def currentBall(currentLocation: Vec): Image =
  ball at currentLocation
```

This is a good example of functional code: we've broken the problem down into small independent functions that we then compose to build the complete solution. We're still missing some parts though: how is user input obtained for example?

If we ignore interactivity for now, we can actually run the code above using `Lists` to provide the input. We fold `currentVelocity` and `currentLocation`, and map `currentBall`.

```scala
val input = List(Up, Down, Up, Down, Left, Right)

val images: List[Image] =
  input.foldRight(Vec(0, 0)){ currentVelocity }
    .foldRight(Vec(0, 0)){ currentLocation }
    .map(currentBall)
```

Our resulting list of images is something that we could display to make an animation.

Missing so far is any notion of time. The values of a `List` are all known in advance, while user input only becomes available when keys are pressed. What we want is some kind of sequence of data where the elements were generated by external input. Imagine, for example, something like a list of keypresses where the next element springs into existence when the user presses a key. We've seen above that the basic interface of `map` and `fold` allows us to express at least some animations.

The next leap is to realise that it's the interface allowing transformation (`map`, `fold`, and so on) that is important, not the list-like nature. We don't want to actually store all the past inputs like we would in a list, for example. We can imagine our transformations as nodes in a directed acyclic graph. Values flow into the graph from user input and so on, and are transformed to, presumably, `Images`.
