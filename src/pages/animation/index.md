# Animation

We are now going to add animations to our graphics library.

The typical imperative approach is animation is to setup a callback that is called every time a new frame should be rendered. The `Canvas` interface provides this facility, with a method `???`.

This has the all problems of imperative approach to drawing that we abandoned in the last chapter: it doesn't compose, is difficult to work with, and is difficult to reason about. What would be a better, functional, approach be?

When we look at a what an animation is, we find it quite amenable to a functional approach. Imagine we are animating a ball moving about the screen. The current position of the ball is a function of the previous postion and the current velocity. The current velocity is itself a function of the user input and the previous velocity. Let's quickly sketch out some code to make this really concrete.

```scala
// User input is a KeyPress
sealed trait KeyPress
final case class Up extends KeyPress
final case class Down extends KeyPress
final case class Left extends KeyPress
final case class Right extends KeyPress

// Velocity is represented as a two dimensional Vector
def currentVelocity(input: KeyPress, previousVelocity: Vec): Vec =
  input match {
    case Up => previousVelocity + Vec(0, 1)
    case Down => previousVelocity + Vec(0, -1)
    case Left => previousVelocity + Vec(-1, 0)
    case Right => previousVelocity + Vec(1, 0)
  }

// Location is represented as a two dimensional Vector, by abuse of notation
def currentLocation(velocity: Vec, previousLocation: Vec): Vec =
  previousLocation + velocity

// A simple image of a ball
val ball = Circle(10) fillColor Color.red

def currentBall(currentLocation: Vec): Image =
  ball at currentLocation
```

This is a good example of functional code: we've broken the problem down into small independent functions that we then compose to build the complete solution. We're still missing some parts though: how is user input obtained for example?

If we ignore interactivity for now, we can actually run the code above using `Lists` as input. We fold `currentVelocity` and `currentLocation`, and map `currentBall`.

```scala
val input = List(Up, Down, Up, Down, Left, Right)

val images: List[Image] =
  input.foldRight(Vec(0, 0)){ currentVelocity }
    .foldRight(Vec(0, 0)){ currentLocation }
    .map(currentBall)
```

Our resulting list of images is something that we could display to make an animation.

Missing so far is any notion of time. The values of a `List` are all known in advance, while user input only becomes available when keys are pressed and the animation refresh cycle happens 60 times per second. What we want is some kind of sequence of data where the elements were generated by external input. Imagine, for example, something like a list of keypresses where the next element springs into existence when the user presses a key. We've seen above that the basic interface of `map` and `fold` allows us to express at least some animations.

The next leap is to realise that it's the interface allowing transformation (`map`, `fold`, and so on) that is important, not the list-like nature. We don't want to actually store all the past inputs like we would in a list, for example. We can imagine our transformations as nodes in a directed acyclic graph. Values flow into the graph from user input and so on, and are transformed to, presumably, `Images`.

We can start sketching an interface. Let's call our type `EventStream[A]`, where the type variable indicates the type of elements that the event stream produces.

```scala
sealed trait EventStream[A] {
  def map[B](f: A => B): EventStream[B]

  def fold[B](seed: B)(f: (A, B) => B): EventStream[B]
}
```
